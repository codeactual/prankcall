Call a function periodically with backoff and other customization

_Source: [lib/prankcall/index.js](../lib/prankcall/index.js)_

<a name="tableofcontents"></a>

- <a name="toc_exportsprankcall"></a><a name="toc_exports"></a>[exports.Prankcall](#exportsprankcall)
- <a name="toc_exportscreate"></a>[exports.create](#exportscreate)
- <a name="toc_exportsextendext"></a>[exports.extend](#exportsextendext)
- <a name="toc_prankcall"></a>[Prankcall](#prankcall)
- <a name="toc_prankcallprototypesend"></a><a name="toc_prankcallprototype"></a>[Prankcall.prototype.send](#prankcallprototypesend)
- <a name="toc_prankcallprototypecalctimeouts"></a>[Prankcall.prototype.calcTimeouts](#prankcallprototypecalctimeouts)
- <a name="toc_prankcalldefaultreceive"></a>[Prankcall.defaultReceive](#prankcalldefaultreceive)
- <a name="toc_prankcallbackoff"></a>[Prankcall.backoff](#prankcallbackoff)

<a name="exports"></a>

# exports.Prankcall()

> Reference to [Prankcall](#prankcall).

<sub>Go: [TOC](#tableofcontents) | [exports](#toc_exports)</sub>

# exports.create()

> Create a new [Prankcall](#prankcall).

**Return:**

`{object}`

<sub>Go: [TOC](#tableofcontents) | [exports](#toc_exports)</sub>

# exports.extend(ext)

> Extend [Prankcall](#prankcall).prototype.

**Parameters:**

- `{object} ext`

**Return:**

`{object}` Merge result.

<sub>Go: [TOC](#tableofcontents) | [exports](#toc_exports)</sub>

# Prankcall()

> Prankcall constructor.

**Usage:**

```js
var prankcall = require('prankcall').create();
prankcall.retry({retries: 3}); // `retry` options

var send = function *() {
   // ... async read ...
   return data;
};
var recv = function *() {
   // ... async read ...
   return true; // keep reading
};

yield prankcall.recv(recv).send(send);
```

**Configuration:**

- `{object} retry` Valid `retry` options
  - To disable: `prankcall.disable('retry')`
  - Default values below are from `retry`
  - `{number} [timeout=2000]`
  - `{number} [retries=10]`
  - `{number} [factor=2]`
  - `{number} [minTimeout=1000]`
  - `{number} [maxTimeout=Infinity]`
  - `{boolean} [randomize=false]`
- `{function *} [receive=none]` Optional consumer of each call's return value
  - `return true` to make another call
  - `return <falsey>` stop calling
- `{number} [sleep=1000]` Delay (in milliseconds) after successful call

**See:**

- [tim-kos/node-retry](https://github.com/tim-kos/node-retry/#api)

<sub>Go: [TOC](#tableofcontents)</sub>

<a name="prankcallprototype"></a>

# Prankcall.prototype.send(*})

> Yield to `sender` and retry after an exception.

- By default, collect only one result from `sender`.
  - Return `true` from a [Prankcall](#prankcall).prototype.receive generator to collect another.
- By default, backoff according to stock `retry` settings.

**Parameters:**

- `{function} *}` sender

<sub>Go: [TOC](#tableofcontents) | [Prankcall.prototype](#toc_prankcallprototype)</sub>

# Prankcall.prototype.calcTimeouts()

> Use `retry` to calculate timeout durations.

**Return:**

`{array}` Ex. `[1000, 2000, 4000, ...]`

<sub>Go: [TOC](#tableofcontents) | [Prankcall.prototype](#toc_prankcallprototype)</sub>

# Prankcall.defaultReceive()

> Err on the side of halting the generator after one call instead of
unexpectedly running it forever.

<sub>Go: [TOC](#tableofcontents) | [Prankcall](#toc_prankcall)</sub>

# Prankcall.backoff()

> Separate from [Prankcall](#prankcall).sleep to allow separate test doubles.

<sub>Go: [TOC](#tableofcontents) | [Prankcall](#toc_prankcall)</sub>

_&mdash;generated by [apidox](https://github.com/codeactual/apidox)&mdash;_
